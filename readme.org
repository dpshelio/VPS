* Visualiser of Positional Astronomy concepts
#+begin_src python
  import matplotlib.pyplot as plt
  import numpy as np

  from matplotlib.patches import Circle, PathPatch, FancyArrowPatch
  from matplotlib.text import TextPath
  from matplotlib.transforms import Affine2D
  import mpl_toolkits.mplot3d.art3d as art3d
  from mpl_toolkits.mplot3d import proj3d

  class Arrow3D(FancyArrowPatch):
      """

      From: https://stackoverflow.com/a/74122407/1087595 by https://stackoverflow.com/users/3157428/ruli
      """
      def __init__(self, xs, ys, zs, *args, **kwargs):
          super().__init__((0,0), (0,0), *args, **kwargs)
          self._verts3d = xs, ys, zs

      def do_3d_projection(self, renderer=None):
          xs3d, ys3d, zs3d = self._verts3d
          xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)
          self.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

          return np.min(zs)

  def rotation_matrix(d):
      """
      Calculates a rotation matrix given a vector d. The direction of d
      corresponds to the rotation axis. The length of d corresponds to
      the sin of the angle of rotation.

      From: https://stackoverflow.com/a/18228967/1087595 by https://stackoverflow.com/users/1150961/till-hoffmann
      Variant of: http://mail.scipy.org/pipermail/numpy-discussion/2009-March/040806.html
      """
      sin_angle = np.linalg.norm(d)

      if sin_angle == 0:
          return np.identity(3)

      d /= sin_angle

      eye = np.eye(3)
      ddt = np.outer(d, d)
      skew = np.array([[    0,  d[2],  -d[1]],
                    [-d[2],     0,  d[0]],
                    [d[1], -d[0],    0]], dtype=np.float64)

      M = ddt + np.sqrt(1 - sin_angle**2) * (eye - ddt) + sin_angle * skew
      return M


  def pathpatch_2d_to_3d(pathpatch, z = 0, normal = 'z'):
      """
      Transforms a 2D Patch to a 3D patch using the given normal vector.

      The patch is projected into they XY plane, rotated about the origin
      and finally translated by z.
      From: https://stackoverflow.com/a/18228967/1087595 by https://stackoverflow.com/users/1150961/till-hoffmann
      """
      if type(normal) is str: #Translate strings to normal vectors
          index = "xyz".index(normal)
          normal = np.roll((1.0,0,0), index)

      normal /= np.linalg.norm(normal) #Make sure the vector is normalised

      path = pathpatch.get_path() #Get the path and the associated transform
      trans = pathpatch.get_patch_transform()

      path = trans.transform_path(path) #Apply the transform

      pathpatch.__class__ = art3d.PathPatch3D #Change the class
      pathpatch._code3d = path.codes #Copy the codes
      pathpatch._facecolor3d = pathpatch.get_facecolor #Get the face color

      verts = path.vertices #Get the vertices in 2D

      d = np.cross(normal, (0, 0, 1)) #Obtain the rotation vector
      M = rotation_matrix(d) #Get the rotation matrix

      pathpatch._segment3d = np.array([np.dot(M, (x, y, 0)) + (0, 0, z) for x, y in verts])

  def pathpatch_translate(pathpatch, delta):
      """
      Translates the 3D pathpatch by the amount delta.
      From: https://stackoverflow.com/a/18228967/1087595 by https://stackoverflow.com/users/1150961/till-hoffmann
      """
      pathpatch._segment3d += delta


  fig = plt.figure()
  ax = fig.add_subplot(projection='3d')

  # Draw a circle for the horizont
  p = Circle((5, 5), 5, alpha=0.5)
  ax.add_patch(p)
  art3d.pathpatch_2d_to_3d(p, z=0, zdir="z")

  # Draw great circle NZS
  p = Circle((5, 0), 5, fill=False, linestyle='-')
  ax.add_patch(p)
  art3d.pathpatch_2d_to_3d(p, z=5, zdir="y")
  # Draw great circle EZW
  p = Circle((5, 0), 5, fill=False, linestyle=':')
  ax.add_patch(p)
  art3d.pathpatch_2d_to_3d(p, z=5, zdir="x")

  # Add labels N, E, S, W, Z
  coord = [((-0.5, 5, 0), "N"),
             ((5, 10.5, 0), "E"),
             ((10.5, 5, 0), "S"),
             ((5, -0.5, 0), "W"),
             ((5,5, 5.2), "Z")]
  for location, label in coord:
      ax.text(*location, label, None, horizontalalignment='center', size='medium')

  # Display NP and equator
  latitude = 45
  lat_r = np.deg2rad(latitude)
  center = (5, 5, 0)
  north_pole = (5 - 5.3 * np.cos(lat_r), 5, 5.3 * np.sin(lat_r))
  np_normal = (np.array(north_pole) - np.array(center)) * np.array([1, 1, -1])
  arrow_prop_dict = dict(mutation_scale=20, arrowstyle='-|>', color='k', shrinkA=0, shrinkB=0)
  a = Arrow3D(*zip(center, north_pole), **arrow_prop_dict)
  ax.add_artist(a)
  ax.text(*north_pole, "NP", None, horizontalalignment='center', size='medium')
  p = Circle((0, 0), 5, facecolor = 'g', alpha=0.2) #Add a circle in the xy plane
  ax.add_patch(p)
  pathpatch_2d_to_3d(p, z=0, normal=np_normal)
  pathpatch_translate(p, (5, 5, 0))
  lat_symbol = (5 - 2.5 * np.cos(lat_r / 2), 5, 2.5 * np.sin(lat_r / 2))
  ax.text(*lat_symbol, r"$\phi$", None, horizontalalignment='center', size='medium')
  # arrow
  steps = np.linspace(0, lat_r, 10)
  steps_arrow = np.array([5, 5, 0])[:, np.newaxis] + np.vstack((-2 *np.cos(steps), np.zeros(10), 2 * np.sin(steps)))
  print(steps_arrow.shape)
  ax.plot(steps_arrow[0,:], steps_arrow[1,:], steps_arrow[2,:])
  # Arrow3D only works with two coordinates, therefore we need to create two parts
  arrow_prop_dict = dict(mutation_scale=20, arrowstyle='-|>', color='k', shrinkA=0, shrinkB=0)
  arrow_top = Arrow3D(steps_arrow[0,-2:], steps_arrow[1,-2:], steps_arrow[2,-2:], **arrow_prop_dict)
  ax.add_artist(arrow_top)
  arrow_prop_dict = dict(mutation_scale=20, arrowstyle='<|-', color='k', shrinkA=0, shrinkB=0)
  arrow_bottom = Arrow3D(steps_arrow[0,0:2], steps_arrow[1,0:2], steps_arrow[2,0:2], **arrow_prop_dict)
  ax.add_artist(arrow_bottom)


  ax.set_xlim(-1, 11)
  ax.set_ylim(-1, 11)
  ax.set_zlim(-6, 6)
  ax.set_aspect('equal')
  plt.show()
